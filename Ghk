import org.apache.poi.xwpf.usermodel.*;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.*;

import java.io.*;
import java.util.*;

public class SafeBookmarkUpdaterIfElse {

    public static void main(String[] args) throws Exception {
        String inputPath = "template.dotx";             // Your template file
        String outputPath = "updated_template.dotx";    // Output result

        // Define the bookmark values
        Map<String, String> bookmarkValues = Map.of(
                "NameField", "Shubham Gupta",
                "AddressField", "Bangalore",
                "DateField", "2025-07-02"
        );

        try (FileInputStream fis = new FileInputStream(inputPath);
             XWPFDocument doc = new XWPFDocument(fis)) {

            // Iterate over all body elements
            for (IBodyElement element : doc.getBodyElements()) {

                if (element instanceof XWPFParagraph paragraph) {
                    updateBookmarksInParagraph(paragraph, bookmarkValues);

                } else if (element instanceof XWPFTable table) {
                    for (XWPFTableRow row : table.getRows()) {
                        for (XWPFTableCell cell : row.getTableCells()) {
                            for (XWPFParagraph para : cell.getParagraphs()) {
                                updateBookmarksInParagraph(para, bookmarkValues);
                            }
                        }
                    }

                } else if (element instanceof XWPFSDT sdt) {
                    String title = sdt.getTitle();
                    if (bookmarkValues.containsKey(title)) {
                        sdt.getContent().clear();
                        sdt.getContent().setText(bookmarkValues.get(title));
                    }

                } else {
                    // Unsupported or unknown element type
                    System.out.println("⚠️ Unknown element type: " + element.getClass());
                }
            }

            try (FileOutputStream fos = new FileOutputStream(outputPath)) {
                doc.write(fos);
            }

            System.out.println("✅ All matching bookmarks updated → " + outputPath);
        }
    }

    // Update bookmark values in a single paragraph
    private static void updateBookmarksInParagraph(XWPFParagraph para, Map<String, String> values) {
        List<CTBookmark> bookmarks = para.getCTP().getBookmarkStartList();

        for (CTBookmark bookmark : bookmarks) {
            String name = bookmark.getName();
            int id = bookmark.getId().intValue();

            if (values.containsKey(name)) {
                replaceTextInsideBookmark(para, id, values.get(name));
            }
        }
    }

    // Replace or insert text strictly inside bookmark range
    private static void replaceTextInsideBookmark(XWPFParagraph para, int bookmarkId, String newText) {
        boolean inBookmark = false;
        boolean replaced = false;

        List<XWPFRun> runs = para.getRuns();

        for (int i = 0; i < runs.size(); i++) {
            XWPFRun run = runs.get(i);

            // Start of bookmark
            if (para.getCTP().getBookmarkStartList().stream().anyMatch(b -> b.getId().intValue() == bookmarkId)) {
                inBookmark = true;
                continue;
            }

            // End of bookmark
            if (inBookmark && para.getCTP().getBookmarkEndList().stream().anyMatch(e -> e.getId().intValue() == bookmarkId)) {
                if (!replaced) {
                    XWPFRun newRun = para.insertNewRun(i);
                    newRun.setText(newText);
                    replaced = true;
                }
                break;
            }

            // Replace existing run text inside bookmark
            if (inBookmark && !replaced && run.text() != null && !run.text().isBlank()) {
                run.setText(newText, 0);
                replaced = true;
            }
        }

        // Add a fallback run if nothing was replaced
        if (inBookmark && !replaced) {
            XWPFRun newRun = para.createRun();
            newRun.setText(newText);
        }
    }
}
